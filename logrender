#!/usr/bin/php
<?php
# Flora Log by LeaskH.com

function direct($string) {
    echo rtrim($string) . "\n";
}

function external_render($string) {
    direct(shell_exec($string));
}

function colorize($string) {
    $string = escapeshellarg($string);
    external_render("echo {$string} | grcat conf.log");
}

function json($string) {
    $string = escapeshellarg($string);
    external_render(
        "echo {$string} | "
      . 'python -mjson.tool | '
      . 'pygmentize -f terminal256 -l javascript -O style=native'
    );
}

function notify($string) {
    $string = escapeshellarg($string);
    shell_exec("/Users/leask/Documents/.flora/notify {$string}");
}

function say($string) {
    $string = escapeshellarg($string);
    shell_exec("say {$string}");
}

function sqlite_open($path) {
    global $dbhandle;
    return $dbhandle = new SQLite3($path);
}

function sqlite_query($sql) {
    global $dbhandle;
    $dbhandle = $dbhandle ?: sqlite_open('rules.db');
    return $dbhandle->query($sql);
}

function sqlite_fetch($sql) {
    $dbResult = sqlite_query($sql);
    if ($dbResult) {
        $result = [];
        while (($row = $dbResult->fetchArray(SQLITE3_ASSOC))) {
            if ($row) {
                $result[] = $row;
            }
        }
        return $result;
    }
    return null;
}

function hitPattern($id) {
    return sqlite_query(
        "UPDATE `rules` SET `hits` = `hits` + 1 WHERE `id` = {$id};"
    );
}

function loadPatterns() {
    global $patterns;
    $rawPatterns = sqlite_fetch('SELECT * FROM `rules` ORDER BY `hits` DESC;');
    $patterns = $rawPatterns ?: [];
}

function despatchLog($string) {
    global $patterns;
    foreach ($patterns as $pItem) {
        if (preg_match($pItem['pattern'], $string)) {
            hitPattern($pItem['id']);
            switch ($pItem['category']) {
                case 'direct':
                    direct($string);
                    return;
                case '500':
                    colorize($string);
                    $strNoti = preg_replace(
                        '/^.*php.*\[\d*\]: PHP [^:]*:\s*(.*)$/',
                        '$1', $string
                    );
                    notify("PHP: {$strNoti}");
                    say("You got a bug!");
                    return;
                case 'php.json':
                    $strReg  = '/^(.*php-cgi.*(POST|RETURN|PROXY|HEADER|POST_FORM|POST_BODY): )(.*)$/';
                    $strMeta = preg_replace($strReg, '$1', $string);
                    $strJson = preg_replace($strReg, '$3', $string);
                    colorize($strMeta);
                    if (preg_match('/<xml>/', $strJson)) {
                        colorize($strJson);
                    } else {
                        json($strJson);
                    }
                    return;
                case 'service':
                    // @todo
                    return;
                case 'ignore':
                    return;
            }
        }
    }
    colorize($string);
}

# Main logic
$previous = '';
loadPatterns();
$hdlLog = fopen('php://stdin', 'r');
while (!feof($hdlLog)) {
    $current = fgets($hdlLog);
    if ($previous !== $current) {
        despatchLog(rtrim($current));
        $previous  =  $current;
    }
}
exit(0);
